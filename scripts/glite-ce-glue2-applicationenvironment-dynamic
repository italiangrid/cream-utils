#!/usr/bin/perl -w
#
# glite-ce-glue2-applicationenvironment-dynamic: an information provider 
# to be used as GIP provider for the ApplicationEnvironment object, in 
# v 2.0 of the GLUE schema
#
# Author: Massimo Sgaravatto, but code heavily copied from
# lcg-info-dynamic-software written by Laurence Field
#
# Ref: http://www.ogf.org/documents/GFD.147.pdf
#      http://glue20.web.cern.ch/glue20/
# Copyright (c) Members of the EGEE Collaboration. 2010.
# See http://www.eu-egee.org/partners/ for details on the copyright
# holders.
#
#     Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use FileHandle;
use POSIX qw(strftime);

my $edgpath   = "/opt/edg/var/info";
my $glitepath = "/opt/glite/var/info" ;

my %subclusters ;
my $AEId;


#
# Version number for this code
my $version = "1.0";


my $host = `hostname -f`;
chomp($host);

my $confile;

# Read in the configuration file (first argument)

my %config = (
              ComputingServiceId => '',
              );

if ($ARGV[0]){
    $confile = $ARGV[0];
    my $fh = new FileHandle $confile
	or die "Error: Can't open configuration file: $ARGV[0]\n";
    foreach (<$fh>){
        if ((! m/^\#/) & (m/=/)){
# For lines containing an = and not starting with #
            m/^(.*?)=\s*(.*)\s*$/;
# Split on the first =, no leading or trailing whitespace in the value
            my $key=$1;
            my $value=$2;
            $key=~s/\s+//g;
            $config{$key}=$value;
        }
    }
open (LDIF, $ARGV[1]) || die "Cannot open '$ARGV[1]': $!,";
}
else{
    print STDERR "Usage: glite-ce-glue2-applicationenvironment-dynamic <config-file> <glue1 static cluster ldif file>\n";
    exit 1;
}


# Holds all the data.
#  $subclusters{<SubClusterUniqueId>}{'dn'} = <dn>
#     Stores the DN per SubCluster.
#  $subclusters{<SubClusterUniqueId>}{'tags'}{<tag>} = 1
#     Stores the key value of a <tag> = 1 if present per SubCluster.




my $cid ;
while (<LDIF>) {
    chomp;
    if (/dn:\s+GlueSubClusterUniqueID=([^,]*),.*$/){
	$cid = $1 ;
#	$subclusters{$cid}{'dn'} = $_ ;
    }
    elsif (/^GlueHostApplicationSoftwareRunTimeEnvironment:\s+(.*)$/) {
	$subclusters{$cid}{'tags'}{$1} = 1 ;
    }

}
close (LDIF);

# Read in tags from old edg location if there is one.
# A little inefficent since reading files for every
# SubCluster but we expect this to die anyway with
# multiple subclusters.
foreach my $sc ( keys %subclusters ) {
  # Readin in $edgpath
    foreach my $tag ( &tagsFromDir($edgpath) ) {
	$subclusters{$sc}{'tags'}{$tag} = $tag ;
    }
  # Readin from $glitepath
    foreach my $tag ( &tagsFromDir("$glitepath/$sc") ) {
	$subclusters{$sc}{'tags'}{$tag} = $tag ;
    }
}


# Finally dump the output.


# Get service id from conf file
my $ServiceID = $config{ComputingServiceId};

# No white space. No "
$ServiceID =~ s/\s+//g;
$ServiceID =~ s/\"//g;

# ManagerId is ServiceId + "_Manager"
my $ManagerId = $ServiceID . "_Manager";


my $bind_dn = "GLUE2ServiceID=$ServiceID,GLUE2GroupID=resource,o=glue";

# Times are mandated to be UTC only
my $TimeNow = strftime("%Y-%m-%dT%H:%M:%SZ", gmtime());

# Hardwire the data validity period to 1 hour for now
my $validity = "3600";


foreach my $sc ( keys %subclusters ) {

    # Print applicationenvironments belonging to subcluster $sc    
    
    # Now start outputting LDIF lines for the Manager object.
    # Note that once we get here we are committed to printing a
    # complete, valid object. Start with the DN ...

    my $resource_bind_dn = "GLUE2ResourceId=$sc," . $bind_dn;



    foreach my $tag ( sort keys %{$subclusters{$sc}{'tags'}} ) {

        # ApplicationEnvironment ID is concatenation of 
        #RTE and ExecutionEnvironment ID 
        $AEId= $tag . "_" . $sc;

        print "dn: GLUE2ApplicationEnvironmentId=$AEId,$resource_bind_dn\n";

        # Print the boilerplate objectclass declarations and unique ID

	print "objectClass: GLUE2Entity\n";
	print "objectClass: GLUE2ApplicationEnvironment\n";

	print "GLUE2EntityCreationTime: $TimeNow\n";

        # Validity is hardwired above
	print "GLUE2EntityValidity: $validity\n";

        # Id
        print "GLUE2ApplicationEnvironmentID: $AEId\n";


        # Use OtherInfo to embed some metadata to help with debugging

        print "GLUE2EntityOtherInfo: InfoProviderName=glite-ce-glue2-applicationenvironment-dynamic\n";
	print "GLUE2EntityOtherInfo: InfoProviderVersion=$version\n";
	print "GLUE2EntityOtherInfo: InfoProviderHost=$host\n";


        # As GLUE2ApplicationEnvironmentAppName we use the tag name
	print "GLUE2ApplicationEnvironmentAppName: $tag\n"  ;

        # Finally link to the Manager
        print "GLUE2ApplicationEnvironmentComputingManagerForeignKey: $ManagerId\n";
        print "\n";

        
    }
}


# The End.


# Take a directory d and look for d/<vo>/<vo>.list files.
# Return an array of them.

sub tagsFromDir() {
    my $d =  shift ;
    my @tags ;
    opendir (DIR, $d) or return @tags ;
    my @contents = readdir (DIR) or return @tags ;
    foreach my $f ( @contents ) {
	next if ($f eq "." or $f eq "..");
	if ( -r "$d/$f/$f.list" ) {
	    open(TAGS,"$d/$f/$f.list")  ;
	    while(<TAGS>) {
		chomp;
              # https://savannah.cern.ch/bugs/?59871
              #Split on new lines.
		push(@tags,split('\s+',$_))  if $_ =~ m/\S+/ ;
	    }

	}
    }
    return @tags ;
}
